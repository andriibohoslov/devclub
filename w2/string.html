<!DOCTYPE html>
<!--[if IE 7]>
<html lang="ru" class="ie7">
<![endif]-->
<!--[if IE 8]>
<html lang="ru" class="ie8">
<![endif]-->
<!--[if (lt IE 7)|(gt IE 8)]><!-->
<html lang="ru">
<!--<![endif]-->
<head>
	<title>Строки</title>
	<meta charset="utf-8">
	<link rel="stylesheet" href="https://my.devclub.com.ua/static/dragonscale.css?43">
	<link rel="stylesheet" href="style.css">
	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
</head>
<body>
	<section>
		<h1>Строки</h1>
		<div>
			<p>Строка&#769; <em>(англ. string)</em> &mdash; последовательность символов. Например, строка 'Hello' состоит из пяти символов.</p>
		</div>
		<aside>
			<table id="str-hello">
				<tr>
					<td>'H'</td>
					<td>'e'</td>
					<td>'l'</td>
					<td>'l'</td>
					<td>'o'</td>
				</tr>
			</table>
		</aside>

		<h2>Представление в памяти</h2>
		<div>
			<p>Поскольку память предназначена для хранения числовых данных, для хранения строк каждому символу ставится в соответствие определенный числовой код. Таблица соответствий символов и кодов называется кодировочной таблицей, или попросту, кодировкой.
			</p>
			<p>Примером наиболее старой и известной кодировки служит <a href="http://ru.wikipedia.org/wiki/ASCII">US-ASCII</a>. Справа приведено шестнадцатиричное представление строки 'Hello' в этой кодировке.</p>
		</div>
		<aside>
			<table id="str-hello">
				<tr>
					<td>48</td>
					<td>65</td>
					<td>6c</td>
					<td>6c</td>
					<td>6f</td>
				</tr>
			</table>
		</aside>

		<h3>Си-строки</h3>
		<div>
			<p>Последовательность символов оканчивается завершающим символом (терминатором). В языке Си в этом качестве применяется служебный символ с кодом 0.</p>
			<p>Получение длины строки требует последовательного перебора символов, пока не будет найден код 0.</p>
			<p>Такие строки называются также нуль-терминированными и ASCIIZ (ASCII-Zero).</p>
			<p><em>Не путайте управляющий символ с кодом 0 (нуль-символ) с собственно цифрой ноль!</em></p>
		</div>
		<aside>
			<table id="str-hello-c">
				<tr>
					<td>48</td>
					<td>65</td>
					<td>6c</td>
					<td>6c</td>
					<td>6f</td>
					<td>00</td>
				</tr>
			</table>
		</aside>

		<h3>Паскаль-строки</h3>
		<div>
			<p>Помимо последовательности символов хранится длина строки. В языке Паскаль длина строки хранилась в виде 8-битного целого числа перед началом последовательности символов.</p>
			<p>Подобный метод хранения строк применяется во многих современных языках программирования. Хранится 32 или 64 бита длины строки, а также указатель на начало последовательности символов.</p>
		</div>
		<aside>
			<table id="str-hello-pascal">
				<tr>
					<td>05</td>
					<td>48</td>
					<td>65</td>
					<td>6c</td>
					<td>6c</td>
					<td>6f</td>
				</tr>
			</table>
		</aside>

		<h2>Использование в языке Си</h2>
		<div>
			<h3>Ввод-вывод</h3>
			<code>char str[10];

scanf("%9s", str);
printf("%s", str);
</code>
			<p>Девятка в шаблоне ввода означает ограничение в 9 символов при считывании. Десятый же символ требуется для записи нуль-терминатора.</p>
			<p>Данный вызов функции scanf будет считывать символы из стандартного потока ввода до нахождения whitespace-символа (пробел, табуляция, перевод строки) либо до завершения потока ввода (конца файла), но не более 9 символов. Нуль-терминатор будет записан автоматически. Что до printf, такой вызов будет выводить в стандартный поток вывода символы до нахождения нуль-терминатора.</p>

			<p><em>Обратите внимание, что если вам необходимо считать строку длиной 10 символов, вам понадобится на один символ больше, то есть 11 символов. Это следует учитывать при выделении памяти.</em></p>
			<p>Также возможна работа при помощи семейства функций fgets/fputs. Функция fgets сама учитывает, что один байт нужен для терминатора.</p>
			<code>char str[10];

fgets(str, 10, stdin);
fputs(str, stdout); // то же самое, что puts(str)
</code>
			<p>Функции gets/fgets работают несколько иначе, чем scanf: разделителем для них служит исключительно перевод строки или конец файла, при этом сам символ перевода строки также считывается.</p>
			<p><em>Несмотря на внешнее сходство, функции gets и fgets ведут себя по-разному. Ниже будут рассмотрены релевантные вопросы безопасности.</em></p>

			<h3>Обработка</h3>
			<p>Поскольку строка в данном случае является массивом кодов символов, то и для обработки доступны все те же инструменты, что и для произвольных массивов.</p>
		</div>
		
		<h2>Безопасность при считывании последовательностей данных</h2>
		<div>
			<p>Рассмотрим следующие фрагменты кода без ограничения объема считываемых данных.</p>
			<code>char str[10];

scanf("%s", str);
</code>
			<code>char str[10];

gets(str);
</code>
			<p>Оба варианта кода считают все символы до перевода строки / whitespace-символа. При получении на вход более девяти таких символов, произойдет попытка записи за пределы массива str. Это событие называется переполнением буфера и имеет негативные последствия.</p>
			<p>Наличие же функции gets, не контролирующей объемы ввода, в стандартной библиотеке языка Си является эпическим провалом его разработчиков. Более того, из-за идиотически слепого стремления к совместимости со старым кодом, данная функция долгое время обитала в стандартной библиотеке (до стандарта C11). В текущем стандарте C11 ее наконец-то решили убрать.</p>
			<p><em>Вместо небезопасной функции gets следует использовать fgets, передавая в качестве указателя на файл указатель на стандартный поток ввода stdin и указав лимит количества символов.</em></p>
		</div>
	</section>
</body>
</html>
